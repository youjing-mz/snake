# 课时2 设计文档 - 核心游戏逻辑

## 文档目的
定义游戏核心逻辑的数据结构和接口规范。

## 核心类型定义

### Snake.gd 接口
```gdscript
class_name Snake
extends Node2D

signal food_eaten(food_value: int)
signal wall_hit
signal self_hit

enum CollisionType { NONE, WALL, SELF, FOOD }

var body: Array[Vector2] = []
var direction: Vector2 = Vector2.RIGHT
var is_growing: bool = false
var move_interval: float = 0.2

func change_direction(new_direction: Vector2) -> void
func check_collision(head_pos: Vector2) -> CollisionType
func grow() -> void
func set_move_speed(speed: float) -> void
func get_head_position() -> Vector2
func get_body_positions() -> Array[Vector2]
func get_length() -> int
func reset() -> void
```

### Food.gd 接口
```gdscript
class_name Food
extends Node2D

signal food_spawned(position: Vector2, value: int)
signal food_consumed(position: Vector2, value: int)

enum FoodType { NORMAL, BONUS, SPECIAL }

var current_position: Vector2 = Vector2(-1, -1)
var current_value: int = Constants.FOOD_SCORE
var is_active: bool = false

func spawn_food(occupied_positions: Array[Vector2]) -> void
func check_collision(position_to_check: Vector2) -> bool
func consume_food() -> int
func get_current_position() -> Vector2
func is_food_active() -> bool
```

### Grid.gd 接口
```gdscript
class_name Grid
extends Node2D

var show_grid: bool = true

func toggle_grid_visibility() -> void
func set_grid_color(color: Color) -> void
```

## 游戏状态管理

### GameState.gd 数据结构
```gdscript
class_name GameState
extends Resource

enum State { MENU, PLAYING, PAUSED, GAME_OVER }

@export var current_state: State = State.MENU
@export var score: int = 0
@export var level: int = 1
@export var high_score: int = 0
@export var game_speed: float = Constants.BASE_MOVE_SPEED
@export var foods_eaten: int = 0

func change_state(new_state: State) -> void
func reset_game_data() -> void
func update_high_score() -> bool
func calculate_level() -> int
func calculate_speed() -> float
```

## 碰撞检测系统

### CollisionDetector.gd 静态工具类
```gdscript
class_name CollisionDetector
extends Node

enum CollisionType { NONE, WALL, SELF, FOOD }

static func check_wall_collision(position: Vector2, grid_width: int, grid_height: int) -> bool
static func check_self_collision(head_position: Vector2, body_positions: Array[Vector2]) -> bool
static func check_food_collision(position: Vector2, food: Food) -> bool
static func detect_collision(head_position: Vector2, body_positions: Array[Vector2], 
                           food: Food, grid_width: int, grid_height: int) -> CollisionType
```

## 性能优化工具

### ObjectPool.gd 对象池
```gdscript
class_name ObjectPool
extends Node

var pools: Dictionary = {}

func create_pool(pool_name: String, create_func: Callable, reset_func: Callable, initial_size: int = 10) -> void
func get_object(pool_name: String)
func return_object(pool_name: String, obj) -> void
```

### AudioManager.gd 音效管理
```gdscript
class_name AudioManager
extends Node

enum SoundType { FOOD_EAT, GAME_OVER, LEVEL_UP, BUTTON_CLICK, PAUSE }

const SOUND_PATHS: Dictionary = {
    SoundType.FOOD_EAT: "res://assets/sounds/food_eat.ogg",
    SoundType.GAME_OVER: "res://assets/sounds/game_over.ogg",
    SoundType.LEVEL_UP: "res://assets/sounds/level_up.ogg"
}

var audio_players: Array[AudioStreamPlayer] = []
var available_players: Array[AudioStreamPlayer] = []

func play_sound(sound_type: SoundType, volume: float = 0.0) -> void
```

## 算法规范

### 蛇移动算法
```
1. 检查方向变化有效性（防反向）
2. 计算新头部位置
3. 执行碰撞检测
4. 根据碰撞结果处理：
   - 无碰撞：正常移动
   - 食物碰撞：增长并生成新食物
   - 障碍碰撞：游戏结束
```

### 食物生成算法
```
1. 获取所有被占用位置
2. 计算可用位置列表
3. 随机选择位置
4. 根据权重随机选择食物类型
5. 更新视觉表现
```

### 碰撞检测优先级
```
1. 边界碰撞（最高优先级）
2. 自身碰撞
3. 食物碰撞（最低优先级）
```

## 数据流设计

### 游戏循环数据流
```
输入事件 → Snake.change_direction()
定时器触发 → Snake.move_snake()
移动完成 → 碰撞检测
碰撞结果 → GameManager处理
状态更新 → UI更新
```

### 信号连接架构
```
Snake信号 → GameManager处理
Food信号 → GameManager处理
GameManager信号 → UI更新
GameManager信号 → AudioManager播放音效
```

## 代码生成要求

### 必须实现的核心功能
- [ ] Snake类：移动逻辑、碰撞检测、视觉渲染
- [ ] Food类：生成逻辑、类型系统、特效
- [ ] Grid类：网格渲染、可视化控制
- [ ] GameState类：状态管理、数据持久化
- [ ] CollisionDetector类：碰撞算法
- [ ] ObjectPool类：性能优化
- [ ] AudioManager类：音效播放

### 质量标准
- [ ] 类型安全：明确的类型声明
- [ ] 错误处理：边界条件检查
- [ ] 性能优化：对象池、渲染优化
- [ ] 可维护性：清晰的接口设计